{"ast":null,"code":"import { LineBasicMaterial, BufferAttribute, Box3, Group, LineSegments } from 'three';\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\nconst boundingBox = new Box3();\n\nclass MeshBVHRootVisualizer extends LineSegments {\n  constructor(mesh, material, depth = 10, group = 0) {\n    super(undefined, material);\n    this.material = material;\n    this.name = 'MeshBVHRootVisualizer';\n    this.depth = depth;\n    this.mesh = mesh;\n    this._group = group;\n    this.update();\n  }\n\n  raycast() {}\n\n  update() {\n    const linesGeometry = this.geometry;\n    const boundsTree = this.mesh.geometry.boundsTree;\n    const group = this._group;\n    linesGeometry.dispose();\n    this.visible = false;\n\n    if (boundsTree) {\n      // count the number of bounds required\n      const targetDepth = this.depth - 1;\n      let boundsCount = 0;\n      boundsTree.traverse((depth, isLeaf) => {\n        if (depth === targetDepth || isLeaf) {\n          boundsCount++;\n          return true;\n        }\n      }, group); // fill in the position buffer with the bounds corners\n\n      let posIndex = 0;\n      const positionArray = new Float32Array(8 * 3 * boundsCount);\n      boundsTree.traverse((depth, isLeaf, boundingData) => {\n        if (depth === targetDepth || isLeaf) {\n          arrayToBox(boundingData, boundingBox);\n          const {\n            min,\n            max\n          } = boundingBox;\n\n          for (let x = -1; x <= 1; x += 2) {\n            const xVal = x < 0 ? min.x : max.x;\n\n            for (let y = -1; y <= 1; y += 2) {\n              const yVal = y < 0 ? min.y : max.y;\n\n              for (let z = -1; z <= 1; z += 2) {\n                const zVal = z < 0 ? min.z : max.z;\n                positionArray[posIndex + 0] = xVal;\n                positionArray[posIndex + 1] = yVal;\n                positionArray[posIndex + 2] = zVal;\n                posIndex += 3;\n              }\n            }\n          }\n\n          return true;\n        }\n      }, group); // fill in the index buffer to point to the corner points\n\n      const edgeIndices = new Uint8Array([// x axis\n      0, 4, 1, 5, 2, 6, 3, 7, // y axis\n      0, 2, 1, 3, 4, 6, 5, 7, // z axis\n      0, 1, 2, 3, 4, 5, 6, 7]);\n      let indexArray;\n\n      if (positionArray.length > 65535) {\n        indexArray = new Uint32Array(12 * 2 * boundsCount);\n      } else {\n        indexArray = new Uint16Array(12 * 2 * boundsCount);\n      }\n\n      for (let i = 0; i < boundsCount; i++) {\n        const posOffset = i * 8;\n        const indexOffset = i * 24;\n\n        for (let j = 0; j < 24; j++) {\n          indexArray[indexOffset + j] = posOffset + edgeIndices[j];\n        }\n      } // update the geometry\n\n\n      linesGeometry.setIndex(new BufferAttribute(indexArray, 1, false));\n      linesGeometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n      this.visible = true;\n    }\n  }\n\n}\n\nclass MeshBVHVisualizer extends Group {\n  get color() {\n    return this._material.color;\n  }\n\n  get opacity() {\n    return this._material.opacity;\n  }\n\n  set opacity(v) {\n    this._material.opacity = v;\n  }\n\n  constructor(mesh, depth = 10) {\n    super();\n    this.name = 'MeshBVHVisualizer';\n    this.depth = depth;\n    this.mesh = mesh;\n    this._roots = [];\n    this._material = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    this.update();\n  }\n\n  update() {\n    const bvh = this.mesh.geometry.boundsTree;\n    const totalRoots = bvh ? bvh._roots.length : 0;\n\n    while (this._roots.length > totalRoots) {\n      this._roots.pop();\n    }\n\n    for (let i = 0; i < totalRoots; i++) {\n      if (i >= this._roots.length) {\n        const root = new MeshBVHRootVisualizer(this.mesh, this._material, this.depth, i);\n        this.add(root);\n\n        this._roots.push(root);\n      } else {\n        let root = this._roots[i];\n        root.depth = this.depth;\n        root.mesh = this.mesh;\n        root.update();\n      }\n    }\n  }\n\n  updateMatrixWorld(...args) {\n    this.position.copy(this.mesh.position);\n    this.rotation.copy(this.mesh.rotation);\n    this.scale.copy(this.mesh.scale);\n    super.updateMatrixWorld(...args);\n  }\n\n  copy(source) {\n    this.depth = source.depth;\n    this.mesh = source.mesh;\n  }\n\n  clone() {\n    return new MeshBVHVisualizer(this.mesh, this.depth);\n  }\n\n  dispose() {\n    this._material.dispose();\n  }\n\n}\n\nexport default MeshBVHVisualizer;","map":{"version":3,"sources":["C:/Users/user/Desktop/workspace/yoru-ui-web/node_modules/three-mesh-bvh/src/MeshBVHVisualizer.js"],"names":["LineBasicMaterial","BufferAttribute","Box3","Group","LineSegments","arrayToBox","boundingBox","MeshBVHRootVisualizer","constructor","mesh","material","depth","group","undefined","name","_group","update","raycast","linesGeometry","geometry","boundsTree","dispose","visible","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","min","max","x","xVal","y","yVal","z","zVal","edgeIndices","Uint8Array","indexArray","length","Uint32Array","Uint16Array","i","posOffset","indexOffset","j","setIndex","setAttribute","MeshBVHVisualizer","color","_material","opacity","v","_roots","transparent","depthWrite","bvh","totalRoots","pop","root","add","push","updateMatrixWorld","args","position","copy","rotation","scale","source","clone"],"mappings":"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","sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, LineSegments } from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\n\r\nconst boundingBox = new Box3();\r\nclass MeshBVHRootVisualizer extends LineSegments {\r\n\r\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper( undefined, material );\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.name = 'MeshBVHRootVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis._group = group;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst linesGeometry = this.geometry;\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tconst group = this._group;\r\n\t\tlinesGeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tarrayToBox( boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\tconst edgeIndices = new Uint8Array( [\r\n\t\t\t\t// x axis\r\n\t\t\t\t0, 4,\r\n\t\t\t\t1, 5,\r\n\t\t\t\t2, 6,\r\n\t\t\t\t3, 7,\r\n\r\n\t\t\t\t// y axis\r\n\t\t\t\t0, 2,\r\n\t\t\t\t1, 3,\r\n\t\t\t\t4, 6,\r\n\t\t\t\t5, 7,\r\n\r\n\t\t\t\t// z axis\r\n\t\t\t\t0, 1,\r\n\t\t\t\t2, 3,\r\n\t\t\t\t4, 5,\r\n\t\t\t\t6, 7,\r\n\t\t\t] );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( 12 * 2 * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( 12 * 2 * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * 24;\r\n\t\t\t\tfor ( let j = 0; j < 24; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + edgeIndices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tlinesGeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tlinesGeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this._material.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this._material.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis._material.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis._roots = [];\r\n\t\tthis._material = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this._material, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet root = this._roots[ i ];\r\n\t\t\t\troot.depth = this.depth;\r\n\t\t\t\troot.mesh = this.mesh;\r\n\t\t\t\troot.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._material.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport default MeshBVHVisualizer;\r\n"]},"metadata":{},"sourceType":"module"}